'use strict';

var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var THREE = require('three');
var fiber = require('@react-three/fiber');
var postprocessing = require('postprocessing');
var threeStdlib = require('three-stdlib');
var maath = require('maath');
var screenSpaceReflections = require('screen-space-reflections');
var n8ao = require('n8ao');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var THREE__namespace = /*#__PURE__*/_interopNamespaceDefault(THREE);

const selectionContext = React.createContext(null);
function Selection({ children, enabled = true }) {
    const [selected, select] = React.useState([]);
    const value = React.useMemo(() => ({ selected, select, enabled }), [selected, select, enabled]);
    return jsxRuntime.jsx(selectionContext.Provider, { value: value, children: children });
}
function Select({ enabled = false, children, ...props }) {
    const group = React.useRef(null);
    const api = React.useContext(selectionContext);
    React.useEffect(() => {
        if (api && enabled) {
            let changed = false;
            const current = [];
            group.current.traverse((o) => {
                o.type === 'Mesh' && current.push(o);
                if (api.selected.indexOf(o) === -1)
                    changed = true;
            });
            if (changed) {
                api.select((state) => [...state, ...current]);
                return () => {
                    api.select((state) => state.filter((selected) => !current.includes(selected)));
                };
            }
        }
    }, [enabled, children, api]);
    return (jsxRuntime.jsx("group", { ref: group, ...props, children: children }));
}

const EffectComposerContext = React.createContext(null);
const EffectComposer = React.memo(React.forwardRef(({ children, camera: _camera, scene: _scene, resolutionScale, enabled = true, renderPriority = 1, autoClear = true, depthBuffer, disableNormalPass, stencilBuffer, multisampling = 8, frameBufferType = THREE.HalfFloatType, }, ref) => {
    const { gl, scene: defaultScene, camera: defaultCamera, size } = fiber.useThree();
    const scene = _scene || defaultScene;
    const camera = _camera || defaultCamera;
    const [composer, normalPass, downSamplingPass] = React.useMemo(() => {
        const webGL2Available = threeStdlib.isWebGL2Available();
        // Initialize composer
        const effectComposer = new postprocessing.EffectComposer(gl, {
            depthBuffer,
            stencilBuffer,
            multisampling: multisampling > 0 && webGL2Available ? multisampling : 0,
            frameBufferType,
        });
        // Add render pass
        effectComposer.addPass(new postprocessing.RenderPass(scene, camera));
        // Create normal pass
        let downSamplingPass = null;
        let normalPass = null;
        if (!disableNormalPass) {
            normalPass = new postprocessing.NormalPass(scene, camera);
            normalPass.enabled = false;
            effectComposer.addPass(normalPass);
            if (resolutionScale !== undefined && webGL2Available) {
                downSamplingPass = new postprocessing.DepthDownsamplingPass({ normalBuffer: normalPass.texture, resolutionScale });
                downSamplingPass.enabled = false;
                effectComposer.addPass(downSamplingPass);
            }
        }
        return [effectComposer, normalPass, downSamplingPass];
    }, [
        camera,
        gl,
        depthBuffer,
        stencilBuffer,
        multisampling,
        frameBufferType,
        scene,
        disableNormalPass,
        resolutionScale,
    ]);
    React.useEffect(() => composer === null || composer === void 0 ? void 0 : composer.setSize(size.width, size.height), [composer, size]);
    fiber.useFrame((_, delta) => {
        if (enabled) {
            gl.autoClear = autoClear;
            if (stencilBuffer && !autoClear)
                gl.clearStencil();
            composer.render(delta);
        }
    }, enabled ? renderPriority : 0);
    const group = React.useRef(null);
    const instance = fiber.useInstanceHandle(group);
    React.useLayoutEffect(() => {
        const passes = [];
        if (group.current && instance.current && composer) {
            const children = instance.current.objects;
            for (let i = 0; i < children.length; i++) {
                const child = children[i];
                if (child instanceof postprocessing.Effect) {
                    const effects = [];
                    while (children[i] instanceof postprocessing.Effect)
                        effects.push(children[i++]);
                    i--;
                    const pass = new postprocessing.EffectPass(camera, ...effects);
                    passes.push(pass);
                }
                else if (child instanceof postprocessing.Pass) {
                    passes.push(child);
                }
            }
            for (const pass of passes)
                composer === null || composer === void 0 ? void 0 : composer.addPass(pass);
            if (normalPass)
                normalPass.enabled = true;
            if (downSamplingPass)
                downSamplingPass.enabled = true;
        }
        return () => {
            for (const pass of passes)
                composer === null || composer === void 0 ? void 0 : composer.removePass(pass);
            if (normalPass)
                normalPass.enabled = false;
            if (downSamplingPass)
                downSamplingPass.enabled = false;
        };
    }, [composer, children, camera, normalPass, downSamplingPass, instance]);
    // Memoize state, otherwise it would trigger all consumers on every render
    const state = React.useMemo(() => ({ composer, normalPass, downSamplingPass, resolutionScale, camera, scene }), [composer, normalPass, downSamplingPass, resolutionScale, camera, scene]);
    // Expose the composer
    React.useImperativeHandle(ref, () => composer, [composer]);
    return (jsxRuntime.jsx(EffectComposerContext.Provider, { value: state, children: jsxRuntime.jsx("group", { ref: group, children: children }) }));
}));

const resolveRef = (ref) => typeof ref === 'object' && ref != null && 'current' in ref ? ref.current : ref;
let i = 0;
const components = new WeakMap();
const wrapEffect = (effect, defaults) => 
/* @__PURE__ */ React.forwardRef(function Effect({ blendFunction = defaults === null || defaults === void 0 ? void 0 : defaults.blendFunction, opacity = defaults === null || defaults === void 0 ? void 0 : defaults.opacity, ...props }, ref) {
    let Component = components.get(effect);
    if (!Component) {
        const key = `@react-three/postprocessing/${effect.name}-${i++}`;
        fiber.extend({ [key]: effect });
        components.set(effect, (Component = key));
    }
    const camera = fiber.useThree((state) => state.camera);
    const args = React.useMemo(() => { var _a, _b; return [...((_a = defaults === null || defaults === void 0 ? void 0 : defaults.args) !== null && _a !== void 0 ? _a : []), ...((_b = props.args) !== null && _b !== void 0 ? _b : [{ ...defaults, ...props }])]; }, 
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(props)]);
    return (jsxRuntime.jsx(Component, { camera: camera, "blendMode-blendFunction": blendFunction, "blendMode-opacity-value": opacity, ...props, ref: ref, args: args }));
});
const useVector2 = (props, key) => {
    const value = props[key];
    return React.useMemo(() => {
        if (typeof value === 'number')
            return new THREE__namespace.Vector2(value, value);
        else if (value)
            return new THREE__namespace.Vector2(...value);
        else
            return new THREE__namespace.Vector2();
    }, [value]);
};

const DepthOfField = React.forwardRef(function DepthOfField({ target, depthTexture, ...props }, ref) {
    const invalidate = fiber.useThree((state) => state.invalidate);
    const { camera } = React.useContext(EffectComposerContext);
    const effect = React.useMemo(() => {
        const effect = new postprocessing.DepthOfFieldEffect(camera, props);
        // Temporary fix that restores DOF 6.21.3 behavior, everything since then lets shapes leak through the blur
        const maskMaterial = effect.maskPass.getFullscreenMaterial();
        maskMaterial.maskFunction = postprocessing.MaskFunction.MULTIPLY_RGB_SET_ALPHA;
        return effect;
    }, [camera, props]);
    React.useLayoutEffect(() => {
        if (target && typeof target !== 'number') {
            const vec = target instanceof THREE.Vector3
                ? new THREE.Vector3().set(target.x, target.y, target.z)
                : new THREE.Vector3().set(target[0], target[1], target[2]);
            effect.target = vec;
        }
        if (depthTexture)
            effect.setDepthTexture(depthTexture.texture, depthTexture.packing);
        invalidate();
    }, [target, depthTexture, effect]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const Autofocus = React.forwardRef(({ target = undefined, mouse: followMouse = false, debug = undefined, manual = false, smoothTime = 0.25, ...props }, fref) => {
    const dofRef = React.useRef(null);
    const hitpointRef = React.useRef(null);
    const targetRef = React.useRef(null);
    const scene = fiber.useThree(({ scene }) => scene);
    const pointer = fiber.useThree(({ pointer }) => pointer);
    const { composer, camera } = React.useContext(EffectComposerContext);
    // see: https://codesandbox.io/s/depthpickingpass-x130hg
    const [depthPickingPass] = React.useState(() => new postprocessing.DepthPickingPass());
    const [copyPass] = React.useState(() => new postprocessing.CopyPass());
    React.useEffect(() => {
        composer.addPass(depthPickingPass);
        composer.addPass(copyPass);
        return () => {
            composer.removePass(depthPickingPass);
            composer.removePass(copyPass);
        };
    }, [composer, depthPickingPass, copyPass]);
    React.useEffect(() => {
        return () => {
            depthPickingPass.dispose();
            copyPass.dispose();
        };
    }, [depthPickingPass, copyPass]);
    const [hitpoint] = React.useState(() => new THREE__namespace.Vector3(0, 0, 0));
    const [ndc] = React.useState(() => new THREE__namespace.Vector3(0, 0, 0));
    const getHit = React.useCallback(async (x, y) => {
        ndc.x = x;
        ndc.y = y;
        ndc.z = await depthPickingPass.readDepth(ndc);
        ndc.z = ndc.z * 2.0 - 1.0;
        const hit = 1 - ndc.z > 0.0000001; // it is missed if ndc.z is close to 1
        return hit ? ndc.unproject(camera) : false;
    }, [ndc, depthPickingPass, camera]);
    const update = React.useCallback(async (delta, updateTarget = true) => {
        var _a;
        // Update hitpoint
        if (target) {
            hitpoint.set(...target);
        }
        else {
            const { x, y } = followMouse ? pointer : { x: 0, y: 0 };
            const hit = await getHit(x, y);
            if (hit)
                hitpoint.copy(hit);
        }
        // Update target
        if (updateTarget && ((_a = dofRef.current) === null || _a === void 0 ? void 0 : _a.target)) {
            if (smoothTime > 0 && delta > 0) {
                maath.easing.damp3(dofRef.current.target, hitpoint, smoothTime, delta);
            }
            else {
                dofRef.current.target.copy(hitpoint);
            }
        }
    }, [target, hitpoint, followMouse, getHit, smoothTime, pointer]);
    fiber.useFrame(async (_, delta) => {
        var _a;
        if (!manual) {
            update(delta);
        }
        if (hitpointRef.current) {
            hitpointRef.current.position.copy(hitpoint);
        }
        if (targetRef.current && ((_a = dofRef.current) === null || _a === void 0 ? void 0 : _a.target)) {
            targetRef.current.position.copy(dofRef.current.target);
        }
    });
    // Ref API
    const api = React.useMemo(() => ({
        dofRef,
        hitpoint,
        update,
    }), [hitpoint, update]);
    React.useImperativeHandle(fref, () => api, [api]);
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [debug
                ? fiber.createPortal(jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsxs("mesh", { ref: hitpointRef, children: [jsxRuntime.jsx("sphereGeometry", { args: [debug, 16, 16] }), jsxRuntime.jsx("meshBasicMaterial", { color: "#00ff00", opacity: 1, transparent: true, depthWrite: false })] }), jsxRuntime.jsxs("mesh", { ref: targetRef, children: [jsxRuntime.jsx("sphereGeometry", { args: [debug / 2, 16, 16] }), jsxRuntime.jsx("meshBasicMaterial", { color: "#00ff00", opacity: 0.5, transparent: true, depthWrite: false })] })] }), scene)
                : null, jsxRuntime.jsx(DepthOfField, { ref: dofRef, ...props, target: hitpoint })] }));
});

const Bloom = wrapEffect(postprocessing.BloomEffect, {
    blendFunction: postprocessing.BlendFunction.ADD,
});

const BrightnessContrast = wrapEffect(postprocessing.BrightnessContrastEffect);

const ChromaticAberration = React.forwardRef(function ChromaticAberration(props, ref) {
    const offset = useVector2(props, 'offset');
    const effect = React.useMemo(() => new postprocessing.ChromaticAberrationEffect({ ...props, offset }), [offset, props]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const ColorAverage = React.forwardRef(function ColorAverage({ blendFunction = postprocessing.BlendFunction.NORMAL }, ref) {
    /** Because ColorAverage blendFunction is not an object but a number, we have to define a custom prop "blendFunction" */
    const effect = React.useMemo(() => new postprocessing.ColorAverageEffect(blendFunction), [blendFunction]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const ColorDepth = wrapEffect(postprocessing.ColorDepthEffect);

const Depth = wrapEffect(postprocessing.DepthEffect);

const DotScreen = wrapEffect(postprocessing.DotScreenEffect);

const Glitch = React.forwardRef(function Glitch({ active = true, ...props }, ref) {
    const invalidate = fiber.useThree((state) => state.invalidate);
    const delay = useVector2(props, 'delay');
    const duration = useVector2(props, 'duration');
    const strength = useVector2(props, 'strength');
    const effect = React.useMemo(() => new postprocessing.GlitchEffect({ ...props, delay, duration, strength }), [delay, duration, props, strength]);
    React.useLayoutEffect(() => {
        effect.mode = active ? props.mode || postprocessing.GlitchMode.SPORADIC : postprocessing.GlitchMode.DISABLED;
        invalidate();
    }, [active, effect, invalidate, props.mode]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const GodRays = React.forwardRef(function GodRays(props, ref) {
    const { camera } = React.useContext(EffectComposerContext);
    const effect = React.useMemo(() => new postprocessing.GodRaysEffect(camera, resolveRef(props.sun), props), [camera, props]);
    // @ts-ignore v6.30.2 https://github.com/pmndrs/postprocessing/pull/470/commits/091ef6f9516ca02efa7576305afbecf1ce8323ae
    React.useLayoutEffect(() => void (effect.lightSource = resolveRef(props.sun)), [effect, props.sun]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const Grid = React.forwardRef(function Grid({ size, ...props }, ref) {
    const invalidate = fiber.useThree((state) => state.invalidate);
    const effect = React.useMemo(() => new postprocessing.GridEffect(props), [props]);
    React.useLayoutEffect(() => {
        if (size)
            effect.setSize(size.width, size.height);
        invalidate();
    }, [effect, size]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const HueSaturation = wrapEffect(postprocessing.HueSaturationEffect);

const Noise = wrapEffect(postprocessing.NoiseEffect, { blendFunction: postprocessing.BlendFunction.COLOR_DODGE });

const Outline = React.forwardRef(function Outline({ selection = [], selectionLayer = 10, blendFunction, patternTexture, edgeStrength, pulseSpeed, visibleEdgeColor, hiddenEdgeColor, width, height, kernelSize, blur, xRay, ...props }, forwardRef) {
    const invalidate = fiber.useThree((state) => state.invalidate);
    const { scene, camera } = React.useContext(EffectComposerContext);
    const effect = React.useMemo(() => new postprocessing.OutlineEffect(scene, camera, {
        blendFunction,
        patternTexture,
        edgeStrength,
        pulseSpeed,
        visibleEdgeColor,
        hiddenEdgeColor,
        width,
        height,
        kernelSize,
        blur,
        xRay,
        ...props,
    }), [
        blendFunction,
        blur,
        camera,
        edgeStrength,
        height,
        hiddenEdgeColor,
        kernelSize,
        patternTexture,
        pulseSpeed,
        scene,
        visibleEdgeColor,
        width,
        xRay,
    ]);
    const api = React.useContext(selectionContext);
    React.useEffect(() => {
        // Do not allow array selection if declarative selection is active
        // TODO: array selection should probably be deprecated altogether
        if (!api && selection) {
            effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);
            invalidate();
            return () => {
                effect.selection.clear();
                invalidate();
            };
        }
    }, [effect, selection, api, invalidate]);
    React.useEffect(() => {
        effect.selectionLayer = selectionLayer;
        invalidate();
    }, [effect, invalidate, selectionLayer]);
    React.useRef();
    React.useEffect(() => {
        var _a;
        if (api && api.enabled) {
            if ((_a = api.selected) === null || _a === void 0 ? void 0 : _a.length) {
                effect.selection.set(api.selected);
                invalidate();
                return () => {
                    effect.selection.clear();
                    invalidate();
                };
            }
        }
    }, [api, effect.selection, invalidate]);
    return jsxRuntime.jsx("primitive", { ref: forwardRef, object: effect });
});

const Pixelation = React.forwardRef(function Pixelation({ granularity = 5 }, ref) {
    /** Because GlitchEffect granularity is not an object but a number, we have to define a custom prop "granularity" */
    const effect = React.useMemo(() => new postprocessing.PixelationEffect(granularity), [granularity]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const Scanline = wrapEffect(postprocessing.ScanlineEffect, { blendFunction: postprocessing.BlendFunction.OVERLAY, density: 1.25 });

const addLight = (light, effect) => light.layers.enable(effect.selection.layer);
const removeLight = (light, effect) => light.layers.disable(effect.selection.layer);
const SelectiveBloom = React.forwardRef(function SelectiveBloom({ selection = [], selectionLayer = 10, lights = [], luminanceThreshold, luminanceSmoothing, intensity, width, height, kernelSize, mipmapBlur, ...props }, forwardRef) {
    if (lights.length === 0) {
        console.warn('SelectiveBloom requires lights to work.');
    }
    const invalidate = fiber.useThree((state) => state.invalidate);
    const { scene, camera } = React.useContext(EffectComposerContext);
    const effect = React.useMemo(() => new postprocessing.SelectiveBloomEffect(scene, camera, {
        blendFunction: postprocessing.BlendFunction.ADD,
        luminanceThreshold,
        luminanceSmoothing,
        intensity,
        width,
        height,
        kernelSize,
        mipmapBlur,
        ...props,
    }), [scene, camera, luminanceThreshold, luminanceSmoothing, intensity, width, height, kernelSize, mipmapBlur, props]);
    const api = React.useContext(selectionContext);
    React.useEffect(() => {
        // Do not allow array selection if declarative selection is active
        // TODO: array selection should probably be deprecated altogether
        if (!api && selection) {
            effect.selection.set(Array.isArray(selection) ? selection.map(resolveRef) : [resolveRef(selection)]);
            invalidate();
            return () => {
                effect.selection.clear();
                invalidate();
            };
        }
    }, [effect, selection, api, invalidate]);
    React.useEffect(() => {
        effect.selection.layer = selectionLayer;
        invalidate();
    }, [effect, invalidate, selectionLayer]);
    React.useEffect(() => {
        if (lights && lights.length > 0) {
            lights.forEach((light) => addLight(resolveRef(light), effect));
            invalidate();
            return () => {
                lights.forEach((light) => removeLight(resolveRef(light), effect));
                invalidate();
            };
        }
    }, [effect, invalidate, lights, selectionLayer]);
    React.useEffect(() => {
        var _a;
        if (api && api.enabled) {
            if ((_a = api.selected) === null || _a === void 0 ? void 0 : _a.length) {
                effect.selection.set(api.selected);
                invalidate();
                return () => {
                    effect.selection.clear();
                    invalidate();
                };
            }
        }
    }, [api, effect.selection, invalidate]);
    return jsxRuntime.jsx("primitive", { ref: forwardRef, object: effect, dispose: null });
});

const Sepia = wrapEffect(postprocessing.SepiaEffect);

const SSAO = React.forwardRef(function SSAO(props, ref) {
    const { camera, normalPass, downSamplingPass, resolutionScale } = React.useContext(EffectComposerContext);
    const effect = React.useMemo(() => {
        if (normalPass === null && downSamplingPass === null) {
            console.error('Please enable the NormalPass in the EffectComposer in order to use SSAO.');
            return {};
        }
        return new postprocessing.SSAOEffect(camera, normalPass && !downSamplingPass ? normalPass.texture : null, {
            blendFunction: postprocessing.BlendFunction.MULTIPLY,
            samples: 30,
            rings: 4,
            distanceThreshold: 1.0,
            distanceFalloff: 0.0,
            rangeThreshold: 0.5,
            rangeFalloff: 0.1,
            luminanceInfluence: 0.9,
            radius: 20,
            bias: 0.5,
            intensity: 1.0,
            color: undefined,
            // @ts-ignore
            normalDepthBuffer: downSamplingPass ? downSamplingPass.texture : null,
            resolutionScale: resolutionScale !== null && resolutionScale !== void 0 ? resolutionScale : 1,
            depthAwareUpsampling: true,
            ...props,
        });
    }, [camera, normalPass, props]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const SMAA = wrapEffect(postprocessing.SMAAEffect);

const FXAA = wrapEffect(postprocessing.FXAAEffect);

const Texture = React.forwardRef(function Texture({ textureSrc, texture, ...props }, ref) {
    const t = fiber.useLoader(THREE.TextureLoader, textureSrc);
    React.useLayoutEffect(() => {
        t.encoding = THREE.sRGBEncoding;
        t.wrapS = t.wrapT = THREE.RepeatWrapping;
    }, [t]);
    const effect = React.useMemo(() => new postprocessing.TextureEffect({ ...props, texture: t || texture }), [props, t, texture]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const ToneMapping = wrapEffect(postprocessing.ToneMappingEffect);

const Vignette = wrapEffect(postprocessing.VignetteEffect);

const ShockWave = wrapEffect(postprocessing.ShockWaveEffect);

const LUT = React.forwardRef(function LUT({ lut, tetrahedralInterpolation, ...props }, ref) {
    const effect = React.useMemo(() => new postprocessing.LUT3DEffect(lut, props), [lut, props]);
    const invalidate = fiber.useThree((state) => state.invalidate);
    React.useLayoutEffect(() => {
        if (tetrahedralInterpolation)
            effect.tetrahedralInterpolation = tetrahedralInterpolation;
        if (lut)
            effect.lut = lut;
        invalidate();
    }, [effect, invalidate, lut, tetrahedralInterpolation]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, dispose: null });
});

const TiltShift = wrapEffect(postprocessing.TiltShiftEffect, { blendFunction: postprocessing.BlendFunction.ADD });

const TiltShiftShader = {
    fragmentShader: `

    // original shader by Evan Wallace

    #define MAX_ITERATIONS 100

    uniform float blur;
    uniform float taper;
    uniform vec2 start;
    uniform vec2 end;
    uniform vec2 direction;
    uniform int samples;

    float random(vec3 scale, float seed) {
        /* use the fragment position for a different seed per-pixel */
        return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
    }

    void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
        vec4 color = vec4(0.0);
        float total = 0.0;
        vec2 startPixel = vec2(start.x * resolution.x, start.y * resolution.y);
        vec2 endPixel = vec2(end.x * resolution.x, end.y * resolution.y);
        float f_samples = float(samples);
        float half_samples = f_samples / 2.0;

        // use screen diagonal to normalize blur radii
        float maxScreenDistance = distance(vec2(0.0), resolution); // diagonal distance
        float gradientRadius = taper * (maxScreenDistance);
        float blurRadius = blur * (maxScreenDistance / 16.0);

        /* randomize the lookup values to hide the fixed number of samples */
        float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);
        vec2 normal = normalize(vec2(startPixel.y - endPixel.y, endPixel.x - startPixel.x));
        float radius = smoothstep(0.0, 1.0, abs(dot(uv * resolution - startPixel, normal)) / gradientRadius) * blurRadius;

        #pragma unroll_loop_start
        for (int i = 0; i <= MAX_ITERATIONS; i++) {
            if (i >= samples) { break; } // return early if over sample count
            float f_i = float(i);
            float s_i = -half_samples + f_i;
            float percent = (s_i + offset - 0.5) / half_samples;
            float weight = 1.0 - abs(percent);
            vec4 sample_i = texture2D(inputBuffer, uv + normalize(direction) / resolution * percent * radius);
            /* switch to pre-multiplied alpha to correctly blur transparent images */
            sample_i.rgb *= sample_i.a;
            color += sample_i * weight;
            total += weight;
        }
        #pragma unroll_loop_end

        outputColor = color / total;

        /* switch back from pre-multiplied alpha */
        outputColor.rgb /= outputColor.a + 0.00001;
    }
    `,
};
class TiltShiftEffect extends postprocessing.Effect {
    constructor({ blendFunction = postprocessing.BlendFunction.NORMAL, blur = 0.15, // [0, 1], can go beyond 1 for extra
    taper = 0.5, // [0, 1], can go beyond 1 for extra
    start = [0.5, 0.0], // [0,1] percentage x,y of screenspace
    end = [0.5, 1.0], // [0,1] percentage x,y of screenspace
    samples = 10.0, // number of blur samples
    direction = [1, 1], // direction of blur
     } = {}) {
        super('TiltShiftEffect', TiltShiftShader.fragmentShader, {
            blendFunction,
            attributes: postprocessing.EffectAttribute.CONVOLUTION,
            uniforms: new Map([
                ['blur', new THREE.Uniform(blur)],
                ['taper', new THREE.Uniform(taper)],
                ['start', new THREE.Uniform(start)],
                ['end', new THREE.Uniform(end)],
                ['samples', new THREE.Uniform(samples)],
                ['direction', new THREE.Uniform(direction)],
            ]),
        });
    }
}
const TiltShift2 = wrapEffect(TiltShiftEffect, { blendFunction: postprocessing.BlendFunction.NORMAL });

const fragment = `
uniform sampler2D uCharacters;
uniform float uCharactersCount;
uniform float uCellSize;
uniform bool uInvert;
uniform vec3 uColor;

const vec2 SIZE = vec2(16.);

vec3 greyscale(vec3 color, float strength) {
    float g = dot(color, vec3(0.299, 0.587, 0.114));
    return mix(color, vec3(g), strength);
}

vec3 greyscale(vec3 color) {
    return greyscale(color, 1.0);
}

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
    vec2 cell = resolution / uCellSize;
    vec2 grid = 1.0 / cell;
    vec2 pixelizedUV = grid * (0.5 + floor(uv / grid));
    vec4 pixelized = texture2D(inputBuffer, pixelizedUV);
    float greyscaled = greyscale(pixelized.rgb).r;

    if (uInvert) {
        greyscaled = 1.0 - greyscaled;
    }

    float characterIndex = floor((uCharactersCount - 1.0) * greyscaled);
    vec2 characterPosition = vec2(mod(characterIndex, SIZE.x), floor(characterIndex / SIZE.y));
    vec2 offset = vec2(characterPosition.x, -characterPosition.y) / SIZE;
    vec2 charUV = mod(uv * (cell / SIZE), 1.0 / SIZE) - vec2(0., 1.0 / SIZE) + offset;
    vec4 asciiCharacter = texture2D(uCharacters, charUV);

    asciiCharacter.rgb = uColor * asciiCharacter.r;
    asciiCharacter.a = pixelized.a;
    outputColor = asciiCharacter;
}
`;
class ASCIIEffect extends postprocessing.Effect {
    constructor({ characters = ` .:,'-^=*+?!|0#X%WM@`, fontSize = 54, cellSize = 16, color = '#ffffff', invert = false, } = {}) {
        const uniforms = new Map([
            ['uCharacters', new THREE.Uniform(new THREE.Texture())],
            ['uCellSize', new THREE.Uniform(cellSize)],
            ['uCharactersCount', new THREE.Uniform(characters.length)],
            ['uColor', new THREE.Uniform(new THREE.Color(color))],
            ['uInvert', new THREE.Uniform(invert)],
        ]);
        super('ASCIIEffect', fragment, { uniforms });
        const charactersTextureUniform = this.uniforms.get('uCharacters');
        if (charactersTextureUniform) {
            charactersTextureUniform.value = this.createCharactersTexture(characters, fontSize);
        }
    }
    /** Draws the characters on a Canvas and returns a texture */
    createCharactersTexture(characters, fontSize) {
        const canvas = document.createElement('canvas');
        const SIZE = 1024;
        const MAX_PER_ROW = 16;
        const CELL = SIZE / MAX_PER_ROW;
        canvas.width = canvas.height = SIZE;
        const texture = new THREE.CanvasTexture(canvas, undefined, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.NearestFilter, THREE.NearestFilter);
        const context = canvas.getContext('2d');
        if (!context) {
            throw new Error('Context not available');
        }
        context.clearRect(0, 0, SIZE, SIZE);
        context.font = `${fontSize}px arial`;
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        context.fillStyle = '#fff';
        for (let i = 0; i < characters.length; i++) {
            const char = characters[i];
            const x = i % MAX_PER_ROW;
            const y = Math.floor(i / MAX_PER_ROW);
            context.fillText(char, x * CELL + CELL / 2, y * CELL + CELL / 2);
        }
        texture.needsUpdate = true;
        return texture;
    }
}
const ASCII = React.forwardRef(({ characters = ` .:,'-^=*+?!|0#X%WM@`, fontSize = 54, cellSize = 16, color = '#ffffff', invert = false }, fref) => {
    const effect = React.useMemo(() => new ASCIIEffect({ characters, fontSize, cellSize, color, invert }), [characters, fontSize, cellSize, color, invert]);
    return jsxRuntime.jsx("primitive", { ref: fref, object: effect });
});

const SSR = React.forwardRef(function SSR({ ENABLE_BLUR = true, USE_MRT = true, ...props }, ref) {
    const { invalidate } = fiber.useThree();
    const { scene, camera } = React.useContext(EffectComposerContext);
    const effect = React.useMemo(() => new screenSpaceReflections.SSREffect(scene, camera, { ENABLE_BLUR, USE_MRT, ...props }), [scene, camera, ENABLE_BLUR, USE_MRT, props]);
    const api = React.useContext(selectionContext);
    React.useEffect(() => {
        var _a;
        if (api && api.enabled) {
            if ((_a = api.selected) === null || _a === void 0 ? void 0 : _a.length) {
                effect.selection.set(api.selected);
                invalidate();
                return () => {
                    effect.selection.clear();
                    invalidate();
                };
            }
        }
    }, [api]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect, ...props });
});

const N8AO = React.forwardRef(({ screenSpaceRadius, quality, aoRadius = 5, aoSamples = 16, denoiseSamples = 4, denoiseRadius = 12, distanceFalloff = 1, intensity = 1, color, }, ref) => {
    const { camera, scene } = fiber.useThree();
    const effect = React.useMemo(() => new n8ao.N8AOPostPass(scene, camera), []);
    React.useLayoutEffect(() => {
        fiber.applyProps(effect.configuration, {
            color,
            aoRadius,
            distanceFalloff,
            intensity,
            aoSamples,
            denoiseSamples,
            denoiseRadius,
            screenSpaceRadius,
        });
    }, [screenSpaceRadius, color, aoRadius, distanceFalloff, intensity, aoSamples, denoiseSamples, denoiseRadius]);
    React.useLayoutEffect(() => {
        if (quality)
            effect.setQualityMode(quality.charAt(0).toUpperCase() + quality.slice(1));
    }, [quality]);
    return jsxRuntime.jsx("primitive", { ref: ref, object: effect });
});

exports.ASCII = ASCII;
exports.Autofocus = Autofocus;
exports.Bloom = Bloom;
exports.BrightnessContrast = BrightnessContrast;
exports.ChromaticAberration = ChromaticAberration;
exports.ColorAverage = ColorAverage;
exports.ColorDepth = ColorDepth;
exports.Depth = Depth;
exports.DepthOfField = DepthOfField;
exports.DotScreen = DotScreen;
exports.EffectComposer = EffectComposer;
exports.EffectComposerContext = EffectComposerContext;
exports.FXAA = FXAA;
exports.Glitch = Glitch;
exports.GodRays = GodRays;
exports.Grid = Grid;
exports.HueSaturation = HueSaturation;
exports.LUT = LUT;
exports.N8AO = N8AO;
exports.Noise = Noise;
exports.Outline = Outline;
exports.Pixelation = Pixelation;
exports.SMAA = SMAA;
exports.SSAO = SSAO;
exports.SSR = SSR;
exports.Scanline = Scanline;
exports.Select = Select;
exports.Selection = Selection;
exports.SelectiveBloom = SelectiveBloom;
exports.Sepia = Sepia;
exports.ShockWave = ShockWave;
exports.Texture = Texture;
exports.TiltShift = TiltShift;
exports.TiltShift2 = TiltShift2;
exports.TiltShiftEffect = TiltShiftEffect;
exports.ToneMapping = ToneMapping;
exports.Vignette = Vignette;
exports.resolveRef = resolveRef;
exports.selectionContext = selectionContext;
exports.useVector2 = useVector2;
exports.wrapEffect = wrapEffect;
